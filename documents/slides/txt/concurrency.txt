Concurrency
1Concurrency1. What is a thread?  General idea and problems (chap 26) 2. The thread API (chap 27) How to use them in c or python and go - Creation, completion, synchronisation with locks and condition variables.  3. How Locks are implemented ? (chap 28)  4. Concurrent data structures (chap29) 5. How condition variables are implemented?(chap30) 6. Semaphores and some general concurrency patterns (chap 31) 7. Concurrency bugs (chap 32) 8. Event-based concurrency (chap 33) 2What is a ThreadWhat are the differences between threads and processes? 
3What is a ThreadWhat are the differences between threads and processes? 
4
Similarities •A Process has one or many threads •PCB for process state, TCB (Thread/Task Control Block) for thread state •The scheduler schedules threads just like it does with a process. •The possible states of a threads are the same as for processes (ready, blocked, running) So, what are the differences? What is a ThreadWhat are the differences between threads and processes? 
5
Differences •A single threaded process is just a process with one thread, thus one stack. A multi threaded process can have many stacks; one per thread. •Threads of a process share the same address space!  •Heap and program code are accessible by all threads within a process!! Major concern •When switching between threads the OS does not need to switch the Page Table. Why?What is a ThreadWhy Threads? Parallelism Spread work over multiple CPUs, and thus finish the job faster! Examples?   
6What is a ThreadWhy Threads? Parallelism Spread work over multiple CPUs, and thus finish the job faster! Examples?   Note! Scheduling multi-threaded processes is addressed in chapter 10, we will come back to this. 7What is a ThreadWhy Threads? Avoid blocking progress Threading enables overlapping I/O operations with other activities within a single program.  Examples? 
8What is a ThreadWhy Threads (26.1)? Discussion What is the difference between parallelism and Concurrency? 
9What is a ThreadWhy Threads? Discussion What is the difference between parallelism and Concurrency? 
10•Concurrency is not parallelism What is a ThreadWhy Threads? Discussion What is the difference between parallelism and Concurrency? 
11•Concurrency is not parallelism •Concurrency is about dealing with lots of things at once, while parallelism is about doing lots of things at once. Concurrency enables parallelism, but parallelism is not the (only) goal of concurrency (Rob Pike, Go programming language) What is a ThreadWhy Threads? Discussion What is the difference between parallelism and Concurrency? 
12•Concurrency is not parallelism •Concurrency is about dealing with lots of things at once, while parallelism is about doing lots of things at once. Concurrency enables parallelism, but parallelism is not the (only) goal of concurrency (Rob Pike, Go programming language) •Concurrency is about making correct systems, while parallelism is about making systems run fast by exploiting the available resources What is a ThreadWhy Threads? Discussion What is the difference between parallelism and Concurrency? 
13•Concurrency is not parallelism •Concurrency is about dealing with lots of things at once, while parallelism is about doing lots of things at once. Concurrency enables parallelism, but parallelism is not the (only) goal of concurrency (Rob Pike, Go programming language) •Concurrency is about making correct systems, while parallelism is about making systems run fast by exploiting the available resources •Parallelism is a subset of currency? What is a ThreadWhy Threads? Discussion What is the difference between parallelism and Concurrency? 
14•Concurrency is not parallelism •Concurrency is about dealing with lots of things at once, while parallelism is about doing lots of things at once. Concurrency enables parallelism, but parallelism is not the (only) goal of concurrency (Rob Pike, Go programming language) •Concurrency is about making correct systems, while parallelism is about making systems run fast by exploiting the available resources •Parallelism is a subset of currency? •You can understand it, but you can’t explain it  What is a ThreadWhy Threads? So why multiple threads when we can have multiple processes? 
15What is a ThreadWhy Threads? So why multiple threads when we can have multiple processes? Threads share the same address space within a process. This gives more possibilities for application development, but at the cost of additional complexity.  What gets complex?  16What is a ThreadWhy Threads? So why multiple threads when we can have multiple processes? Threads share the same address space within a process. This gives more possibilities for application development, but at the cost of additional complexity.  What gets complex?  17What is a Thread
18#include <stdio.h> #include <assert.h> #include <pthread.h> void *mythread(void *arg) {     printf("%s\n", (char *) arg);     return NULL; } int main(int argc, char *argv[]) {     pthread_t p1, p2;     int rc;     printf("main: begin\n");     rc = pthread_create(&p1, NULL, mythread, "A");     assert(rc == 0);     rc = pthread_create(&p2, NULL, mythread, "B");     assert(rc == 0);     // join waits for the threads to finish     rc = pthread_join(p1, NULL);     assert(rc == 0);     rc = pthread_join(p2, NULL);     assert(rc == 0);     printf("main: end\n");     return 0; Run this program t0.c What is a ThreadAnd this program t1.c 
19#include <stdio.h> #include <assert.h> #include <pthread.h> static volatile int counter = 0; void *mythread(void *arg) {     printf("%s: begin\n", (char *) arg);     int i;     for (i = 0; i < 1e5; i++) {         counter++;         // counter = counter + 1;     }     printf("%s: end\n", (char *)arg);     return NULL; } int main(int argc, char *argv[]) {     pthread_t p1, p2;     printf("main: begin (counter = %d)\n", counter);     int rc;     rc = pthread_create(&p1, NULL, mythread, "A");     assert(rc == 0);     rc = pthread_create(&p2, NULL, mythread, "B");     assert(rc == 0);     rc = pthread_join(p1, NULL);     assert(rc == 0);     rc = pthread_join(p2, NULL);     assert(rc == 0);     printf("main: end (counter = %d)\n", counter);     return 0; } What is a ThreadThe heart of the problem (26.4)? Sharing data leads to problems. 1. Race Condition /Data Race  
20 
A critical section is that piece of code that when executed by multiple threads may results in a race condition. Solution? What is a ThreadThe heart of the problem (26.4)? Sharing data leads to problems. 1. Race Condition /Data Race  
21 
A critical section is that piece of code that when executed by multiple threads may results in a race condition. Solution? Mutual Exclusion What is a ThreadDemo:  Race condition again in Python and go  
22What is a Thread
23Def. Critical Section: a piece of code that accesses (read or write) a shared variable or resource and must not be concurrently executed by more than one thread. A critical section is code that when executed by multiple threads may result in a race condition. What we want: Def. Mutual Exclusion: guarantee that if one thread is executing within the critical section, other threads are prevented from doing so! Edsger Dijkstra
-coined these terms
-Pioneer in the ﬁeldWhat is a ThreadThe Wish for Atomicity We need some basic operations that we know are not going to be interrupted. Atomic operations!  
24What is a Thread (chap26)Summary 
25Thread API Concurrency with GoCritical section and mutex.  Exercise 1:  the program lock-task1.go can increment and decrement a counter. It is not thread safe, can you modify the code to make it thread safe.  
26Thread API Concurrency with GoProducer Consumer  Exercise 2: 
27Locks (Chapter 28)We need a synchronization primitive to make sure that a piece of code (critical section) can only be accessed by one thread at the time.  This primitive is called lock and provides mutual exclusion, also referred to as mutex.   
28Locks (Chapter 28)We need a synchronization primitive to make sure that a piece of code (critical section) can only be accessed by one thread at the time.  This primitive is called lock and provides mutual exclusion, also referred to as mutex.   
29
In CLocks (Chapter 28)We need a synchronization primitive to make sure that a piece of code (critical section) can only be accessed by one thread at the time.  This primitive is called lock and provides mutual exclusion, also referred to as mutex.   
30In Go: visit the info repo for the complete code “atomic-counter.go”func (sc *SafeCounter) increment() {     sc.Mu.Lock()     sc.Val++     sc.Mu.Unlock() } Locks (Chapter 28)28.4 Evaluating Locks Evaluation criteria Correctness: Does the lock provide mutual exclusion? 
31Locks (Chapter 28)28.4 Evaluating Locks Evaluation criteria Correctness: Does the lock provide mutual exclusion? Fairness: Are the threads waiting for the lock fairly treated? 
32Locks (Chapter 28)28.4 Evaluating Locks Evaluation criteria Correctness: Does the lock provide mutual exclusion? Fairness: Are the threads waiting for the lock fairly treated? Performance: Time overhead due to lock. Consider few threads waiting, many threads waiting, single CPU and multiple CPUs. 33Locks (Chapter 28)28.5 Controlling Interrupts Idea: Disable interrupt when a thread enters the critical section. Correctness: Does the lock provide mutual exclusion? 
34
Locks (Chapter 28)28.5 Controlling Interrupts Idea: Disable interrupt when a thread enters the critical section. Correctness: Does the lock provide mutual exclusion? 
35
On Single CPU Yes Easy to see that disabling interrupts means no other thread can access the shared variables. On Multiple CPUs No Every CPU has its own interrupt, but the memory is still shared! Locks (Chapter 28)28.5 Controlling Interrupts Idea: Disable interrupt when a thread enters the critical section. Fairness: Are the threads waiting for the lock fairly treated? 
36
Locks (Chapter 28)28.5 Controlling Interrupts Idea: Disable interrupt when a thread enters the critical section. Fairness: Are the threads waiting for the lock fairly treated? 
37
No Relies on well behaving threads/user programs. Wrong assumption Many things can go wrong with this approach Locks (Chapter 28)28.5 Controlling Interrupts Idea: Disable interrupt when a thread enters the critical section. Performance: Time overhead due to lock. Consider few threads waiting, many threads waiting, single CPU and multiple CPUs. 
38
Poor solution anyway no need to answer this question Locks (Chapter 28)28.6 Locks using load and store Correctness: Does the lock provide mutual exclusion? 
39
This is Spin-waitingLocks (Chapter 28)28.6 Locks using load and store Correctness: Does the lock provide mutual exclusion? No, even if we assume atomic load and store. 
40
ﬂag=0ﬂag=1line 9line 9 and line 11 and more…timer interruptthread 1thread 2atomic load or store
ﬂag=0line 11 and more …ﬂag=1Both thread 1 and 2 are in the critical sectionLocks (Chapter 28)28.6 Locks using load and store Correctness: Does the lock provide mutual exclusion? No, even if we assume atomic load and store. 
41
Locks (Chapter 28)28.7 Spin Locks with Test-And-Set We need useful atomic instructions to implement locks: test-and-set instruction / atomic exchange instruction 
42
Allows to return the old value while setting the new value in ONE big operation (atomic). Also referred to as transaction. Locks (Chapter 28)28.7 Spin Locks with Test-And-Set We need useful atomic instructions to implement locks: test-and-set instruction / atomic exchange instruction 
43
value=0Example: old=TestAndSet(value, 1)line 3value=1old=nilold=0line 4line 2Transaction / AtomicLocks (Chapter 28)28.7 Spin Locks with Test-And-Set So how to use this to implement a lock? 
44
Locks (Chapter 28)28.8 Evaluating Spin Locks Correctness, fairness, performance?  
45
Locks (Chapter 28)28.8 Evaluating Spin Locks Correctness: Yes Fairness: Starvation  Performance on signal CPU: Poor. A thread holding a lock under context switch, other threads will spin the entire time slice hoping for a lock that is not going to be released soon. (wasting an entire time slot) 46Locks (Chapter 28)28.8 Evaluating Spin Locks Correctness: Yes Fairness: Starvation  Performance on multiple CPUs: better if the number of threads roughly equals the the number of CPUs. Not the case though  Lookup the notes and read page 323 for explanation.  Remark The idea is too simplistic, since every thread is on different CPU, using a time slice on one cpu does not penalize another thread on another CPU. But… 47Locks (Chapter 28)28.9 Compare-And-Swap Slightly more powerful primitive than Test-And-Set 
48
Locks (Chapter 28)28.9 Compare-And-Swap (CAS) What to modify to implement a lock with CAS? 
49
Locks (Chapter 28)28.9 Compare-And-Swap (CAS) What to modify to implement a lock with CAS? 
50
CompareAndSwap(&lock->ﬂag,0,1)Locks (Chapter 28)28.9 Evaluating Spin Locks with CAS Correctness: Yes Fairness: Starvation  Performance on signal CPU: Poor. A thread holding a lock under context switch, other threads will spin the entire time slice hoping for a lock that is not going to be released soon. (wasting an entire time slot) 51Locks (Chapter 28)28.9 Compare-And-Swap (CAS) Why is it considered as a lock free synchronization? Hint: Try to reason about a concurrent counter with CompareAndSwap and with TestAndSet 
52
Locks (Chapter 28)28.9 Compare-And-Swap (CAS) Why is it considered as a lock free synchronization? Hint: https://www.youtube.com/watch?v=8XJ8r_n7POY&ab_channel=RobEdwards 
53
Locks (Chapter 28)28.9 Compare-And-Swap (CAS) With CAS it is possible to implement a lock free safe counter, but not with TestAndSet (TAS) See atomic-counter.go in info repos under demos 
54Locks (Chapter 28)28.10 Load-Linked and Store-Condition Not syllabus 
55Locks (Chapter 28)28.11 Fetch-And-Add Another atomic operation that can be used to implement a lock. 
56
Locks (Chapter 28)28.11 Fetch-And-Add Lock with Fetch-And-Add 
57
Locks (Chapter 28)28.11 Fetch-And-Add Lock with Fetch-And-Add Correctness: Yes Fairness: Yes Performance: No, still spin-waiting 
58Locks (Chapter 28)28.12 Spin locks are too much spinning Waste of resources 
59Locks (Chapter 28)28.13 Just Yield, (Baby) Now, we need the OS! Assumes an OS primitive yield()—> a thread can ask to go from running to ready state. 
60
Locks (Chapter 28)28.13 Just Yield, (Baby) What issues can arise?  
61
Locks (Chapter 28)28.13 Just Yield, (Baby) What issues can arise? Unnecessary context switch.  100 threads, 1 holding the lock, all others will try to find out the the lock is taken and yield again. Can we avoid this  
62
Locks (Chapter 28)
63
28.14 Using Queues  - park(): puts the thread to blocked - unpark(id): puts the thread to ready - access to CS is when flag=1(the lock) - acquire the guard to manipulate the queue (adding to queue and park, remove from queue and unpark) unlock(): - unpack() systematically leaves flag=1 for the thread just woken up, and sets guard=0  Locks (Chapter 28)
64
guard=0ﬂag=0q=[]Thread 1lock_tThread 2Locks (Chapter 28)
65
guard=0ﬂag=0q=[]guard=1ﬂag=0q=[]Thread 1lock(…)lock_tThread 2line 14Locks (Chapter 28)
66
guard=0ﬂag=0q=[]guard=1ﬂag=0q=[]Thread 1lock(…)lock_tThread 2line 14lock(…)line 14Spins waiting for guardLocks (Chapter 28)
67
guard=0ﬂag=0q=[]guard=1ﬂag=0q=[]Thread 1lock(…)guard=0ﬂag=1q=[]lock_tThread 2line 14line 17lock(…)line 14line 16Locks (Chapter 28)
68
guard=0ﬂag=0q=[]guard=1ﬂag=0q=[]Thread 1lock(…)guard=0ﬂag=1q=[]lock_tThread 2line 14line 17lock(…)line 14guard=1ﬂag=1q=[]line 14line 16Got the guardNow thread1 is in the CSLocks (Chapter 28)
69
guard=0ﬂag=0q=[]guard=1ﬂag=0q=[]Thread 1lock(…)guard=0ﬂag=1q=[]lock_tThread 2line 14line 17lock(…)line 14guard=1ﬂag=1q=[]line 14guard=0ﬂag=1q=[thread2]line 20line 16line 21Add self to queueNow thread1 is in the CSLocks (Chapter 28)
70
guard=0ﬂag=0q=[]guard=1ﬂag=0q=[]Thread 1lock(…)guard=0ﬂag=1q=[]lock_tThread 2line 14line 17lock(…)line 14guard=1ﬂag=1q=[]line 14guard=0ﬂag=1q=[thread2]line 20line 16line 21Now thread2 is blocked (park)Now thread1 is in the CSLocks (Chapter 28)
71
guard=0ﬂag=0q=[]guard=1ﬂag=0q=[]Thread 1lock(…)guard=0ﬂag=1q=[]lock_tThread 2line 14line 17lock(…)line 14guard=1ﬂag=1q=[]line 14guard=0ﬂag=1q=[thread2]line 20line 16line 21Now thread2 is blocked (park)Now thread1 is in the CSDiscuss unlock(lock_t *m) ! Locks (Chapter 28)28.15 Different OS, Different Support Not syllabus 
72Locks (Chapter 28)28.16 Two-Phase Locks Not syllabus 
73Locks (Chapter 28)Summary - Locks are synchronisation primitives - Locks ensure safe manipulation of the critical section - To implement a lock we need atomic operations (hardware support) - Some atomic operations such as CompareAndSwap enable some lock-free synchronization - To avoid unnecessary spinning we need OS support Yield, Park, Unpark for example 74Condition Variables (Chapter 30)Locks don’t let waiting threads to know when a condition is fulfilled, unless they have to check it them selfs.  Lets revisit the python and go examples from the info repo 
75Condition Variables (Chapter 30)Condition Variable definition 
76Def. Condition Variable:  an explicit queue that threads can put themselves on when some condition is not satisfied, to wait for that condition to become true. Another thread can change said condition, and then signal (to wake up one or more) waiting threads allowing them to continue. Go doc: sync.Cond implements a condition variable, a rendezvous point for goroutines waiting for or announcing the occurrence of an event. Condition Variables (Chapter 30)
77func NewCond(mutex Locker) *Cond func (*Cond) Wait() func (*Cond) Signal() Wait(): -Wait() assumes that the associated mutex is locked when Wait() is called -Wait() will atomically: -Release the mutex lock, then -Put calling goroutine to sleep -When goroutine wakes up after being signaled by some other goroutine -Must re-acquire mutex lock before resuming after the line of Wait() Signal(): Always hold the lock when calling Rule: Hold the lock when calling Signal() and Wait().Condition Variables (Chapter 30)
78func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
Producer about to produceConsumer got the lock to access “items”var cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
79func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
Has produced but cannot put the item in “items” yet. Needs the lock!No item to consume, must waitvar cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
80func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
Producer checks if “items” is filled (it is not)Wait() puts the consumer in block state, and releases the lock (we don’t see that)var cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
81func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
Producer adds an item to “items”Wait() puts the consumer in block state, and releases the lock (we don’t see it)var cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
82func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
Producer signals to wake up the consumer and still holds the lockWait() puts the consumer in block state, and releases the lock (we don’t see it)var cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
83func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
Producer signals to wake up consumer and still holds the lockConsumer gets woken up, but needs to get the lock again! (we don’t see that)var cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
84func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
Producer signals to wake up consumer and still holds the lockConsumer still waits the lock to get released (still in wait)var cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
85func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
Producer releases the lockConsumer gets the lock inside wait() (we don’t see that)var cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
86func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
The producer can now access “items”The consumer releases the lockvar cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
87func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
The producer can now add produced items to “items”The consumer needs the lock to check if there are items to consumevar cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
88func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
The producer signals, but no one is waiting anywaysThe consumer needs the lock to check if there are items to consumevar cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
89func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
The producer releases the lockThe consumer needs the lock to check if there are items to consumevar cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
90func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
The producer tries to acquire the lock againThe consumer consumes and signal, but no one is waiting anywaysvar cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
91func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
Now if the items is filled again! Imagine: The producer happens to be fast !Imagine:  The consumer happens to be slowvar cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
92func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
The producer waits, and within wait releases the lockThe consumer can get the lock and consumevar cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
93func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
The producer goes to wait, and within wait releases the lockThe consumer can get the lock, consume, and signal again. var cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
94func produce() {     prod_count := 0     for prod_count < 100 {         item := rand.Intn(100)         cond.L.Lock()         if len(items) == MAX_ITEMS {             //producer waiting             cond.Wait()         }         items = append(items, item)         prod_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }func consume() {     consume_count := 0     for consume_count < 100 {         cond.L.Lock()         if len(items) == 0 {             //consumer waits             cond.Wait()         }         item := items[0]         items = items[1:]         consume_count += 1         cond.Signal()         cond.L.Unlock()         time.Sleep(some periode)     }     Wg.Done() }Go routine producerGo routine consumer
The point: if items is neither filled or empty, they just compete on accessing “items”. Otherwise they can wait() (sleep/block) until they can continue working.  More efficient than just using locksvar cond = sync.NewCond(&Mu)var items = make([]int, 0) Condition Variables (Chapter 30)
95Discuss this code Semaphores (Chapter 31)Definition Aim: Single primitive for all things related to synchronization called Semaphore.  Replacement for Locks and Condition variables 
96Semaphores (Chapter 31)Definition Locks and Condition variables capabilities in one abstraction called Semaphore 
97
Invariant The negative number tells us about the number of waiting threads Semaphores (Chapter 31)31.2 Binary Semaphore (Locks) The usage depends on how the semaphore is initiated What X should be if we only want 1 thread at the time in the critical section? 
98
// Lock()Unlock()Semaphores (Chapter 31)31.2 Binary Semaphore (Locks) The usage depends on how the semaphore is initiated What X should be if we only want 1 thread at the time in the critical section? X=1 
99
// Lock()Unlock()Semaphores (Chapter 31)31.2 Binary Semaphore (Locks) Example with 1 thread 
100
Semaphores (Chapter 31)31.2 Binary Semaphore (Locks) Example with 2 threads 
101
Semaphores (Chapter 31)31.3 Semaphore for Ordering Usage pattern (Similar to condition variables):  - One thread waiting for something to happen - Another thread making that something happen 
102Semaphores (Chapter 31)31.3 Semaphore for Ordering Example: parent waiting for child. What should X be? 
103
Semaphores (Chapter 31)31.3 Semaphore for Ordering Example: parent waiting for child. What should X be? X=0 
104
Semaphores (Chapter 31)31.4 Semaphore for Producer/Consumer Problem Study this code! 
105Semaphores (Chapter 31)31.5 Reader-Writer locks  Is another general problem that can be solved by semaphores. The idea is to exploit the nature of the operations.  Insert modifies a list delete item modifies a list read does not modify a list Basically a lock for reading and a lock for writing and a careful in the way to acquire them and release them.   106Semaphores (Chapter 31)31.5 Reader-Writer locks    
107Initiate two locks and a reader countacquire basic lock and increase the number of readers. If there is a reader (==1) disable writing by acquiring write lockacquire basic lock and decrease the number of readers. If there is no reader (==0) enable writing by releasing write lockPoint:  Disable writing if reading  Semaphores (Chapter 31)31.6 The Dining Philosophers Problem 
108
Semaphores (Chapter 31)31.6 The Dining Philosophers Problem 
109
This solution does not work, why?   Semaphores (Chapter 31)31.6 The Dining Philosophers Problem 
110
This solution does not work, why? Deadlock: Every p holds the left fork waiting for the right one Semaphores (Chapter 31)31.6 The Dining Philosophers Problem 
111
P=4 is just an agreed on number. Break the cycle This solution avoids deadlock. Starvation? Semaphores (Chapter 31)31.7 How to Implement Semaphores  
112
Making semaphore with a lock, a condition variable and a value, is easy.  Curiously, making condition variable from a semaphore is difficult.  Maybe not so general as we might think.  Semaphores (Chapter 31)Summary •Can be used instead of locks with an inherent mechanism of waking up and putting to sleep threads •Can be used for the producer consumer problem rather than lock and condition variable •Reader writer lock: basically a two locks application (with tricks) •Dinning Philosophers: Basically a multi lock application (with tricks) •Easy to make Semaphore from condition variable •Hard to make Condition Variable from Semaphore  113Common Concurrency Problems (Chapter 32)Read it on your own, discuss and search. Questions Under which conditions deadlocks occurs? Under which conditions starvation occurs? What is a race condition? What is atomicity violation? What is order violation? 114Go Channelshttps://www.youtube.com/watch?v=f6kdp27TYZs&ab_channel=GoogleforDevelopers Some exercises based on channels. 
115Go Channelshttps://www.youtube.com/watch?v=f6kdp27TYZs&ab_channel=GoogleforDevelopers Agents A1 and A2, will concurrently search for a value that is multiple of some X. The value must be less than some Max and the search should not last more than Y iterations 
116A1A2MainExitExitLinkGo Channelspackage demos import (     "fmt"     "math/rand"     "time" ) type SearchingAgent struct {     Link       chan int     Multiple   int     Iterations int     Max        int     Name       string     Exit       chan int } func (ag *SearchingAgent) Search() {    Implement this function!!!         } func RunAgentDemo() {     link := make(chan int)     exit := make(chan int)     agent1 := SearchingAgent{Name: "A1", Multiple: 110, Max: 3000, Iterations: 300, Link: link, Exit: exit}     agent2 := SearchingAgent{Name: "A2", Multiple: 110, Max: 3000, Iterations: 300, Link: link, Exit: exit}     go agent1.Search()     go agent2.Search()     <-exit     <-exit     fmt.Println("Done playing") 117Go Channelshttps://www.youtube.com/watch?v=f6kdp27TYZs&ab_channel=GoogleforDevelopers Some exercises based on channels. 
118Go Channels
119Translation between Process Algebra and GOS:ServerP:PrinterC:ClientbaaServer (S): Send channel a on channel bClient (C): Receive channel a and send through it Printer (P): Receive in a and print contentSystem: b<a> | b(a).a<x> | a(x)SCPGo Channels
120Translation between Process Algebra and GO
S:ServerP:PrinterC:ClientbaaServer (S): Send channel a on channel bClient (C): Receive channel a and send through it Printer (P): Receive in a and print contentSystem: b<a> | b(a).a<x> | a(x)SCPfuncmain() {S:= func(a chanint, b chanchanint) {b <-a}P:= func(a chanint) {fmt.Println("Printing ", <-a)}C:= func(b chanchanint) {a:= <-ba <-11}system:= func() {a:= make(chanint)b:= make(chanchanint)goP(a)goC(b)goS(a, b)}system()}